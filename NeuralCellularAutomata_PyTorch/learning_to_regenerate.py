# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_LearningToRegenerate.ipynb.

# %% auto 0
__all__ = ['create_hole', 'CorruptedPool']

# %% ../nbs/03_LearningToRegenerate.ipynb 3
from .core import *
from .learning_to_grow import *
from .what_persists_exists import *

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import matplotlib.pyplot as plt
from tqdm import tqdm
from functools import partial
import fastcore.all as fc

# %% ../nbs/03_LearningToRegenerate.ipynb 9
def create_hole(batch):
    B, C, H, W = batch.shape

    # create a grid with the same size as the batch and values in the range [-1, 1]
    grid = torch.meshgrid(torch.linspace(-1, 1, H), torch.linspace(-1, 1, W))
    grid = torch.stack(grid, dim=0).unsqueeze(0).repeat(B, 1, 1, 1)

    # create a tensor containing the locations of the centers of the holes
    center = torch.rand(B, 2, 1, 1) - 0.5        # random uniform destribution in the range [-0.5, 0.5]
    # create a tensor containing the radius of each hole
    radius = 0.3 * torch.rand(B, 1, 1, 1) + 0.1   # random uniform destribution in the range [0.1, 0.4]
    
    mask = ((grid - center) * (grid - center)).sum(1, keepdim=True).sqrt() > radius

    return batch * mask.float().to(batch.device)

# %% ../nbs/03_LearningToRegenerate.ipynb 12
class CorruptedPool(SamplePool):


    def sample_with_damage(self, num_samples=8, damaged_samples=3):
        # selecting a random sample from the pool
        self.idxs = torch.randperm(self.pool_size)[:num_samples]
        batch = self.pool[self.idxs, ...]

        # sort the indexes according to the loss
        losses = self.loss_fn(batch[:, :4, :, :])
        sorted_idxs = torch.argsort(losses)

        # find the sample in the batch with the highest loss and replace it with the seed
        # to avoid "catastrofic forgetting" (i.e. forgetting how to generate the target from the seed)
        replace_idx = sorted_idxs[-1]
        batch[replace_idx] = self.seed[0]

        # find the k(=damaged_samples) samples with the lowest losses
        # and add some damage to them
        damaged_idxs = sorted_idxs[:damaged_samples]

        # create a hole in the selected images
        batch[damaged_idxs] = create_hole(batch[damaged_idxs])

        return batch
